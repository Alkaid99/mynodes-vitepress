# SQL 简介

SQL（Structured Query Language）是一种用于管理**关系数据库**管理系统（RDBMS）的标准计算机语言。它用于插入、查询、更新和删除数据库中的数据，以及执行其他任务，如创建新表和存储过程。SQL 是一种声明性语言，这意味着您只需指定您想要完成的操作，而不需要指定如何完成它。

SQL 的特点：

- SQL 是一种高级语言，它提供了一种简单、易于理解的方式来管理和操作关系数据库。
- SQL 是一种声明性语言，这意味着您只需指定您想要完成的操作，而不需要指定如何完成它。
- SQL 是一种标准化语言，它被广泛应用于各种不同类型的数据库系统中。
- SQL 具有强大的查询能力，可以轻松地从大量数据中检索信息。

## 语法基础

**SQL 语法特点：**

- SQL 不区分大小写，但关键字通常以大写形式出现
- 所有 SQL 语句都以关键字开头，如`SELECT`、`INSERT`、`UPDATE`、`DELETE`、`ALTER`、`DROP`、`CREATE`、`USE`和`SHOW`等，并且所有语句都以分号`;`结尾
  
**SQL 语法注释：**

- MySQL 支持单行注释和多行注释两种形式。单行注释可以使用`#`符号或者`–`符号，后面直接加上注释内容。多行注释使用`/`和`/`包围起来的内容。

```sql
-- 这是一个单行注释
SELECT * FROM customers; -- 这也是一个单行注释

/*
这是一个多行注释
它可以跨越多行
*/
SELECT * FROM orders;
```

当在任何一款 RDBMS 中执行 SQL 命令时，系统首先确定执行请求的最佳方式，然后 SQL 引擎将会翻译 SQL 语句，并处理请求任务。

整个执行过程包含了多种组件，比如：

- 查询调度程序
- 优化引擎
- 传统的查询引擎
- SQL 查询引擎

传统查询引擎能够处理所有的非 SQL 命令，但是 SQL 引擎并不能处理逻辑文件。

![sql](../8.Rdbms/images/0SI012P-0.gif)

**SQL 语法分类：**

与关系型数据库有关的 SQL 命令包括`CREATE`、`SELECT`、`INSERT`、`UPDATE`、`DELETE`、`DROP`等，根据其特性，可以将它们分为以下几个类别：

| 类别  | 含义                                                               | 主要语句                     |
| ----- | ------------------------------------------------------------------ | ---------------------------- |
| `DDL` | Data Definition Language，用于定义数据库对象，如表、视图、索引等。 | `CREATE`、`ALTER`和`DROP`    |
| `DML` | Data Manipulation Language，用于对数据库中的数据进行增删改操作     | `INSERT`、`UPDATE`和`DELETE` |
| `DQL` | Data Query Language，用于查询数据库中的数据                        | `SELECT`                     |
| `DCL` | Data Control Language，用于控制数据库的访问权限和安全性            | `GRANT`和`REVOKE`            |
| `TCL` | Transaction Control Language，用于管理事务                         | `COMMIT`和`ROLLBACK`         |

## RDBMS

数据库管理系统（Database Management System，缩写：DBMS）是一种针对对象数据库，为管理数据库而设计的大型电脑软件管理系统。

### 表（Table）

在 RDBMS 中，数据被存储在一种称为表（Table）的数据库对象中，它和 Excel 表格类似，都由许多行（Row）和列（Column）构成。每一行都是一条数据，每一列都是数据的一个属性，整个表就是若干条相关数据的集合。

表是关系型数据库中最常见、最简单的数据存储形式。

下面是一个名为`website`的网站信息表的示例：

```sql
+----+----------------+----------------------------+-----+-------+---------+---------+
| id | name           | url                        | age | alexa | uv      | country |
+----+----------------+----------------------------+-----+-------+---------+---------+
|  1 | 百度           | https://www.baidu.com/     |  21 |     4 |  5010.5 | CN      |
|  2 | 淘宝           | https://www.taobao.com/    |  17 |     8 | 3996.75 | CN      |
|  3 | Google         | https://www.google.com/    |  23 |     1 |   36474 | US      |
|  4 | GitHub         | https://github.com/        |  13 |    95 |   216.3 | US      |
|  5 | Stack Overflow | https://stackoverflow.com/ |  16 |    48 |   592.2 | US      |
|  6 | Yandex         | http://www.yandex.ru/      |  11 |    53 |  591.82 | RU      |
|  7 | VK             | https://vk.com/            |  23 |    23 |    1206 | RU      |
+----+----------------+----------------------------+-----+-------+---------+---------+
```

### 字段（Field）

每个表都由若干列构成，每一列都称为一个字段（Field），上表 website 所包含的字段有`id`、`name`、`url`、`age`、`alexa`、`uv`和`country`。

字段用来维护数据表中每一条数据（记录）的特定信息。

### 列（Column）

列（Column）是从垂直方向观察表中的数据，它包含了与某个字段相关联的所有信息。

例如，`website`表中有一列为`url`，它表示网站的地址，如下所示：

```sql
+----------------------------+
| url                        |
+----------------------------+
| https://www.baidu.com/     |
| https://www.taobao.com/    |
| https://www.google.com/    |
| https://github.com/        |
| https://stackoverflow.com/ |
| http://www.yandex.ru/      |
| https://vk.com/            |
+----------------------------+
```

### 记录（Record）

数据表中的每一行数据都称为一条记录（Record），有多少行数据就有多少条记录。

字段是从垂直方向看表中的数据，记录是从水平方向看表中的数据。

表`website`共有 8 条记录，以下是第 3 条记录：

```sql
+----+----------------+----------------------------+-----+-------+---------+---------+
|  3 | Google         | https://www.google.com/    |  23 |     1 |   36474 | US      |
+----+----------------+----------------------------+-----+-------+---------+---------+
```

### 空值（NULL）

字段的取值可以为`NULL`，此时意味着该字段是空的，没有任何值，所以`NULL`被称为空值。

注意，`NULL`和零值不一样，和包含空白符（空格、缩进、换行等）的字段也不一样，`NULL`字段是指在添加记录的时候留空的字段，也即不为该字段指定任何值。

## SQL 约束

约束（Constraint）是指表的数据列必须强行遵守的规则，这些规则用于限制插入表中的数据的值，这样能够确保每份数据的准确定和可靠性。

约束可以是列级别，也可以是表级别；列级约束仅作用于某一列，而表级约束则作用于整张表。

下面是 SQL 常用的一些约束：

| 约束          | 说明                                                   |
| ------------- | ------------------------------------------------------ |
| `NOT NULL`    | 非空约束，确保列中不能有`NULL`值。                     |
| `DEFAULT`     | 默认约束，如果未指定值，那么列将提供默认值。           |
| `UNIQUE`      | 唯一约束，确保列中所有的值都不相同。                   |
| `PRIMARY KEY` | 主键，用来唯一标识数据表中的每一行/记录。              |
| `FOREIGN KEY` | 外键，用于将两个表连接在一起，让两个表的数据保持同步。 |
| `CHECK`       | 检查性约束，用于限定列的取值范围。                     |
| `INDEX`       | 索引，用于快速从数据库中检索或者获取数据。             |

### 主键

主键（Primary Key）由表中的一个或者多个字段构成，用来唯一标识表中的每一行记录。可以将主键类比为学号、身份证号、车牌号或者 ID。

主键必须包含唯一值，换句话说，所有记录的主键都不能出现相同的值。此外，主键必须是一个具体的值，不能是 NULL 值。相当于唯一约束和非空约束的组合。

- 在设计主键时，应使用尽可能少的字段，这不但能减少存储空间，还能提升查询性能。主键包含的字段越少，所需要的存储空间就越小，就性能而言，更少的数据意味着更快速地处理。
- SQL 规定，主键长度不能超过 900 个字节。Oracle 规定，主键不能超过 32 个字段。

除此之外，还有联合主键。联合主键是由一张表中**多个字段组成的主键**。这些字段的值的组合能唯一地标识表中的每一行。

*例如，设置学生选课数据表时，使用学生编号做主键还是用课程编号做主键呢？如果用学生编号做主键，那么一个学生就只能选择一门课程。如果用课程编号做主键，那么一门课程只能有一个学生来选。显然，这两种情况都是不符合实际情况的。实际上设计学生选课表，要限定的是一个学生只能选择同一课程一次。因此，学生编号和课程编号可以放在一起共同作为主键，这也就是联合主键了。*

**参考示例：**

1. 设置主键

    创建单列主键有两种方式，一种是在定义字段的同时指定主键：

    ```sql
    CREATE TABLE student(
        sid INT PRIMARY KEY,
        name VARCHAR(20) NOT NULL COMMENT '姓名'
    );
    ```

    一种是定义完字段后指定主键：

    ```sql
    CREATE TABLE student(
        sid INT,
        name VARCHAR(20) NOT NULL COMMENT '姓名',
        PRIMARY KEY (id)
    );
    ```

2. 设置联合主键

    当主键是由多个字段组成时，不能直接在字段名后面声明主键约束。

    ```sql
    CREATE TABLE student(
        sid INT,
        name VARCHAR(20) NOT NULL COMMENT '姓名',
        PRIMARY KEY (id,name)
    );
    ```

3. 如果表和字段已存在

    如果 student 表和 sid 字段都已经存在，则可以使用`ALTER TABLE`命令添加主键：

    ```sql
    ALTER TABLE student ADD PRIMARY KEY(sid);
    ```

4. 删除主键

    ```sql
    ALTER TABLE student DROP PRIMARY KEY;
    ```

### 外键

SQL 外键（Foreign Key）用于将两个表连接在一起，让两个表的数据保持同步。

外键由表中的一个字段或者多个字段构成，一个表的外键用来指向另一个表的主键（Primary Key）。包含外键的表称为从表，被指向的表称为主表。从表的数据受到主表的约束，向从表中插入或者更新数据时，外键的值必须存在于主表的主键中。

下面的例子能够很好地说明什么是外键。现在有两个表，分别是 user 和 score：

| id  | name | birthday   | address                         | phone       |
| --- | ---- | ---------- | ------------------------------- | ----------- |
| 1   | 张三 | 2000-01-01 | 翻斗大街翻斗花园 1 号楼 1001 室 | 13111111111 |
| 2   | 李四 | 2001-03-03 | 翻斗大街翻斗花园 2 号楼 1001 室 | 15222222222 |
| 3   | 王五 | 1999-12-12 | 翻斗大街翻斗花园 3 号楼 1001 室 | 17333333333 |

| oid | uid | chinese | mathematics | english |
| --- | --- | ------- | ----------- | ------- |
| 1   | 3   | 90      | 95          | 80      |
| 2   | 2   | 60      | 70          | 80      |
| 3   | 1   | 32      | 99          | 10      |

其中 user 表中的 id 是主键；score 表中的 iod 是主键， uid 是外键。score 表的外键 uid 指向 user 表的主键 id，uid 的取值受到 id 的制约，uid 的值必须存在于 id 中，否则无法被接受。

## 数据的完整性

每个 RDBMS 都存在以下几种类别的数据完整性：

- 实体完整性：表中的一行（一条记录）代表一个实体，表中不能有重复的行。
- 域完整性：域也即字段，域完整性用来保证字段的取值是合理的。
- 引用完整性：一个表中的字段可以引用另外一个表中的记录。如果某条记录被另外一个表中的字段引用，那么该记录不能被删除。
- 自定义完整性：除了以上三种基本的完整性约束，不同版本的 RDBMS 在实现时，还可以根据其具体的应用环境，自己制定一些其它的完整性约束。

## 数据库范式

设计关系型数据库时，需要遵守一些特定的规范才能设计出合理的数据库，这些规范就称为“范式”，满足不同程度的规范就是不同的范式。范式的目的在于：

- 消除冗余数据，比如，不应该将两份相同的数据存储到不同的表中；
- 确保数据之间的关联性是有意义的。

以上两点不但能减少数据库占用的存储空间，还能确保数据之间有清晰的逻辑关系。

关系型数据库之父 Edgar Frank "Ted" Codd 提出了六种范式，但是从长期实践看，三种范式更具有实际的意义：

1. 第一范式（1NF），确保每列保持原子性，属性不可分割。
2. 第二范式（2NF），确保表中每列都和主键相关，符合第一范式，同时非属性完全依赖于主键。
3. 第三范式（3NF），确保每列都和主键直接相关，而不是间接相关，符合第二范式，并消除传递依赖。

*2NF 和 3NF 的区别在于有没有分出 2 张表，2NF 如果一张表中包含多种不同实体属性，那么必须要分成多张表。3NF 已经分成多表后，一张表中只有有另一张表的主键，而不能有其他信息。*

遵守的范式级别越高，数据的冗余越少，下一级别的范式包含上一级别的所有范式；也就是说，范式级别越高越严格。

**1NF 举例：**

假如有一个表，列如下：

| 学号 | 姓名 | 联系方式 |
| ---- | ---- | -------- |
|      |      |          |

其中**联系方式**，可以是微信、QQ、手机、邮箱等等，所以这一列是没有满足第一范式的要求。

*要求表中的每列都只包含一个值，不可以包含多个值。*

**2NF 举例：**

假如有一个表，列如下：

| 学号 | 姓名 | 出生日期 | 班级 | 班级编号 | 家庭地址 | 手机号码 | 语文成绩 | 数学成绩 | 英语成绩 | 总成绩 |
| ---- | ---- | -------- | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ------ |
|      |      |          |      |          |          |          |          |          |          |

在这个表中，其实存储了三类信息：学生信息、班级信息和成绩信息。通常会将不同类别的信息分开存储在不同的表中，以便于管理和查询。应该将三个信息分别存储在三个表中。

| 学号 | 姓名 | 出生日期 | 家庭地址 | 手机号码 |
| ---- | ---- | -------- | -------- | -------- |
|      |      |          |          |          |

| 班级 | 班级编号 |
| ---- | -------- |
|      |          |

| 学号 | 语文成绩 | 数学成绩 | 英语成绩 | 总成绩 |
| ---- | -------- | -------- | -------- | ------ |
|      |          |          |          |        |

*一张表只存储一种数据信息。*

**3NF 举例：**

假如有一个表，列如下：

| 学号 | 语文成绩 | 数学成绩 | 英语成绩 | 总成绩 |
| ---- | -------- | -------- | -------- | ------ |
|      |          |          |          |        |

在这个表格中，总成绩这一列并不直接依赖于主键（假设学号是主键），而是间接依赖于语文成绩、数学成绩和英语成绩三列。因此，这个表格不满足 3NF 的要求。

为了使这个表格满足第三范式的要求，可以删除总成绩这一列。当需要查询学生的总成绩时，可以通过计算语文成绩、数学成绩和英语成绩三列得到。

*表中列的数据不能依赖其他列的数据。*

## 数据类型

数据类型（data_type）是指系统中所允许的数据的类型。MySQL 数据类型定义了列中可以存储什么数据以及该数据怎样存储的规则。

数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。

如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。

MySQL 支持多种数据类型，大致可以分为四类：

- 数值类型（整数+小数）
- 日期时间类型
- 字符串类型
- 二进制类型

定义字段的数据类型对数据库的优化是十分重要的。

*以 MySQL 8.0 为例讲解 SQL 数据类型，其它数据库支持的数据类型与 MySQL 大体类似，但是细节（例如数据类型的名称、数据类型的大小等）有所差别。*

### 数值类型

数字类型又分为整数与小数

**整数类型：**

| 类型             | 大小（字节） | 范围（有符号）                                          | 范围（无符号）                  | 说明     |
| ---------------- | ------------ | ------------------------------------------------------- | ------------------------------- | -------- |
| `TINYINT`        | 1            | -128 至 127                                             | 0 至 255                        | 超小整数 |
| `SMALLINT`       | 2            | -32,768 至 32,767                                       | 0 至 65,535                     | 小整数   |
| `MEDIUMINT`      | 3            | -8,388,608 至 8,388,607                                 | 0 至 16777215                   | 整数     |
| `INT`或`INTEGER` | 4            | -2,147,483,648 至 2,147,483,647                         | 0 至 4,294,967,295              | 大整数   |
| `BIGINT`         | 8            | -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 | 0 至 18,446,744,073,709,551,615 | 超大整数 |

在 SQL 中，数值类型的范围分为有符号范围和无符号范围。有符号数字类型可以存储正数和负数，而无符号数字类型只能存储正数。例如，在 MySQL 中，`TINYINT`类型的有符号范围是-128 到 127，而无符号范围是 0 到 25512。

这意味着如果您使用无符号`TINYINT`，则可以存储的最小值为 0，最大值为 255。但是，如果您使用有符号`TINYINT`，则可以存储的最小值为-128，最大值为 127。

当需要存储可能为负数的值时，应该使用有符号数字类型。例如，如果需要存储温度（可能低于零度），或者需要存储账户余额（可能为负数），则应该使用有符号数字类型。

当需要存储的值永远不会为负数时，应该使用无符号数字类型。例如，如果需要存储年龄、数量或者 ID 等值，这些值都不可能为负数，则应该使用无符号数字类型。

在 MySQL 中，所有数值类型（包括整数类型和浮点类型）默认都是有符号的。这意味着它们可以存储负数和正数。如果您想定义无符号的数值类型，可以在类型名称后添加关键字`UNSIGNED`。

**小数类型：**

| 类型               | 分类             | 说明                                                                                                                                                                                                      |
| ------------------ | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `FLOAT(size, d)`   | 浮点数（近似值） | 单精度浮点数类型，4 个字节大小。`size`参数用来指定数字的总个数，`d`参数用来指定小数部分（小数点后边）的数字个数。                                                                                         |
| `FLOAT(p)`         | ^                | 单精度浮点数类型，参数 `p`用来决定使用`FLOAT`类型还是`DOUBLE`类型：<br/>如果`p`的取值介于 0 和 24 之间，那么数据类型将变成`FLOAT()`；<br/>如果`p`的取值介于 25 和 53 之间，那么数据类型将变成`DOUBLE()`。 |
| `DOUBLE(size, d)`  | ^                | 双精度浮点数类型，8 个字节大小。`size`参数用来指定数字的总个数，`d`参数用来指定小数部分（小数点后边）的数字个数。                                                                                         |
| `DECIMAL(size, d)` | 定点数（精确值） | 定点数类型，`size`参数用来指定数字的总个数，`d`参数用来指定小数部分（小数点后边）的数字个数。`size`的最大值是 65，默认值是 10；`d`的最大取值是 30，默认值是 0。                                           |
| `DEC(size, d)`     | ^                | 等价于`DECIMAL(size, d)`。                                                                                                                                                                                |

`FLOAT`和`DOUBLE`类型表示近似数值数据值，它们的精度取决于硬件和操作系统。在大多数情况下，`FLOAT`类型可以精确到小数点后 6-7 位，而`DOUBLE`类型可以精确到小数点后 15-16 位。虽然`DOUBLE`比`FLOAT`精度高，但由于占内存更大，运算速度慢。且即使是`DOUBLE`, 依然会存在精度损失的问题。

- 物体的重量或人的身高，可以使用`FLOAT`或`DOUBLE`数据类型。
- 需要存储精确值，例如金融数据，建议使用`DECIMAL`数据类型

### 日期时间类型

| 类型             | 类型               | 范围                                                     | 赋值格式              |
| ---------------- | ------------------ | -------------------------------------------------------- | --------------------- |
| `DATE`           | 日期类型           | `1000-01-01`到`9999-12-31`                               | `YYYY-MM-DD`          |
| `DATETIME(fsp)`  | 日期和时间类型     | `1000-01-01 00:00:00`到 `9999-12-31 23:59:59`            | `YYYY-MM-DD hh:mm:ss` |
| `TIMESTAMP(fsp)` | 时间戳类型         | `1970-01-01 00:00:01(UTC)` 到 `2038-01-09 03:14:07(UTC)` | `YYYY-MM-DD hh:mm:ss` |
| `TIME(fsp)`      | 时间类型           | `-838:59:59`到`838:59:59`                                | `hh:mm:ss`            |
| `YEAR`           | 四位数字的年份格式 | `1901`到`2155`                                           | `YYYY`                |

- `fsp`是可选参数，表示小数秒精度，范围为 0 到 6。如果未指定 fsp，则默认值为 0。
- 当未给`TIMESTAMP`字段赋值时，自动以当前时间赋值，而`DATETIME`值为 NULL。
- 当使用 2 位数给`YEAR`赋值时，会自动补全 4 位数：
  - 01~69 视为 2001~2069
  - 70~79 视为 1970~1999

在当前的实现下，`TIMESTAMP`类型无法表示`2038 年 1 月 19 日 03:14:07`之后的时间。不过，MySQL 开发人员正在努力解决这个问题，并且可能会在未来的版本中通过扩展 TIMESTAMP 数据类型来支持更大范围的时间值。

如果需要存储 2038 年之后的时间值，可以考虑使用`DATETIME`数据类型。它不受 2038 年问题的影响，并且可以表示从公元 1000 年到 9999 年之间的时间值。

### 字符串类型

| 类型            | 说明                                                                                                               |
| --------------- | ------------------------------------------------------------------------------------------------------------------ |
| `CHAR(size)`    | 用于表示固定长度的字符串，该字符串可以包含数字、字母和特殊字符。`size`的大小可以是从 0 到 255 个字符，默认值为 1。 |
| `VARCHAR(size)` | 用于表示可变长度的字符串，该字符串可以包含数字、字母和特殊字符。`size`的大小可以是从 0 到 65535 个字符。           |
| `TINYTEXT`      | 表示一个最大长度为 255（28-1）的字符串文本。                                                                       |
| `TEXT(size)`    | 表示一个最大长度为 65,535（216-1）的字符串文本，也即 64KB。                                                        |
| `MEDIUMTEXT`    | 表示一个最大长度为 16,777,215（224-1）的字符串文本，也即 16MB。                                                    |
| `LONGTEXT`      | 表示一个最大长度为 4,294,967,295（232-1）的字符串文本，也即 4GB。                                                  |

- 固定长度的字符串：如果不够指定字符个数时，右边用空格不全字符个数，超出时无法写入数据。
- 可变长度的字符串：按照实际大小分配存储空间，但它要在总长度上加 1 字符，这个用来存储位置，超出时无法写入数据。

### 枚举类型

| 类型                         | 说明                                                                                                                       |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `ENUM(val1, val2, val3,...)` | 字符串枚举类型，最多可以包含 65,535 个枚举值。插入的数据必须位于列表中，并且只能命中其中一个值；如果不在，将插入一个空值。 |
| `SET( val1,val2,val3,....)`  | 字符串集合类型，最多可以列出 64 个值。插入的数据可以命中其中的一个或者多个值，如果没有命中，将插入一个空值。               |

- `ENUM`类型相当于单选题；`SET`类型相当于多选题。

### 二进制类型

二进制类型通常用于存储原始的二进制数据，例如图片、视频、exe 文件等。这些数据以二进制形式存储，而不是文本形式。

| 类型              | 说明                                                                                                          |
| ----------------- | ------------------------------------------------------------------------------------------------------------- |
| `BIT(size)`       | 二进制位（Bit）类型，位数由 `size`参数指定；`size`的大小从 1 到 64，默认值为 1。                              |
| `BINARY(size)`    | 等价于`CHAR()`类型，但是存储的是二进制形式的字节串。`size` 参数以字节（Byte）为单位指定列的长度，默认值为 1。 |
| `VARBINARY(size)` | 等价于`VARCHAR()`类型，但是存储的是二进制形式的字节串。`size`参数以字节（Byte）为单位指定列的最大长度。       |
| `TINYBLOB`        | 存储较小的二进制数据，最多可容纳 255 (28-1) 个字节。                                                          |
| `BLOB(size)`      | 用来储存二进制数据，最多可以容纳 65,535（216-1）个字节，也即 64KB。                                           |
| `MEDIUMBLOB`      | 存储中等大小的二进制数据，最多可以容纳 16,777,215（224-1）字节，也即 16MB。                                   |
| `LONGBLOB`        | 存储较大的二进制数据，最多可容纳 42,94,967,295（232-1）字节，也即 4GB。                                       |

## 自动增长序列

序列是一组有顺序的整数，例如 1、2、3、4 ......。序列在数据库中经常被使用，因为很多程序都要求表中的每一行都包含唯一值，序列提供了一种生成唯一值的简单方法。

MySQL 中使用序列的最简单方法是为某一列添加`AUTO_INCREMENT`关键字。`AUTO_INCREMENT`会在新记录插入表中时生成一个唯一的整数（初始值默认为 1），这些整数是自动增长的，用户还可以指定增长的步长（增长默认为 1）。

**注意事项：**

- 一个表中只能有一个字段使用`AUTO_INCREMENT`关键字，并且该字段的类型必须是整数，习惯上将主键设置为`AUTO_INCREMENT`。
- 在插入数据或者更新数据时，一般将 AUTO_INCREMENT 字段留空，因为数据库引擎会自动管理它的值。
- 该字段只能是整数类型，且最大值受该字段的数据类型约束，如果达到上限`AUTO_INCREMENT`就会失效。
- 在 DELETE 数据后，自动增长会从断点开始。

在插入或者更新记录时，如果为`AUTO_INCREMENT`字段明确地指定了一个值，则会出现两种情况：

1. 如果指定的值和已有的编号重复，则出现错误信息，操作失败，因为`AUTO_INCREMENT`字段的值必须是唯一的。
2. 如果指定的值大于已有的编号，则操作成功，该值被插入/更新到表中，下一个编号将从这个新值开始递增；也就是说，`AUTO_INCREMENT`并不要求编号是连续的，可以跳过一些编号。

**参考示例：**

1. 设置自动增长序列

    创建一张名为 url 的表，将 ID 字段设置为主键，并添加`AUTO_INCREMENT`关键字，然后给该表插入几条数据。

    ```sql
    CREATE TABLE web(
        sid INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(30) NOT NULL,
        url VARCHAR(2083) NOT NULL
    );
    INSERT INTO web(sid,name,url) VALUES 
        (NULL,'百度','www.baidu.com'),
        (NULL,'谷歌','www.google.com'),
        (NULL,'必应','www.bing.com');
    SELECT * FROM web;
    ```

    ```sql
    +-----+--------+----------------+
    | sid | name   | url            |
    +-----+--------+----------------+
    |   1 | 百度   | www.baidu.com  |
    |   2 | 谷歌   | www.google.com |
    |   3 | 必应   | www.bing.com   |
    +-----+--------+----------------+
    ```

2. 指定自增字段初始值

    默认情况下，MySQL 从整数 1 开始序列的增长，但是也可以在创建表时指定其它的任何整数。下面的代码中，序列将从 1000 开始：

    ```sql
    CREATE TABLE web_1(
        sid INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(30) NOT NULL,
        url VARCHAR(2083) NOT NULL
    )AUTO_INCREMENT = 1000;
    INSERT INTO web_1(sid,name,url) VALUES 
        (NULL,'百度','www.baidu.com'),
        (NULL,'谷歌','www.google.com'),
        (NULL,'必应','www.bing.com');
    SELECT * FROM web_1;
    ```

    ```sql
    +------+--------+----------------+
    | sid  | name   | url            |
    +------+--------+----------------+
    | 1000 | 百度   | www.baidu.com  |
    | 1001 | 谷歌   | www.google.com |
    | 1002 | 必应   | www.bing.com   |
    +------+--------+----------------+
    ```

    如果表已经存在，也可以使用`ALTER TABLE`设置初始序列值：

    ```sql
    ALTER TABLE web_1 AUTO_INCREMENT = 1000;
    ```

3. 对现有序列重新编号

    在某些情况下，如果已经从表中删除了很多记录，并且想要对所有记录重新编号，此时可以使用一个简单的技巧：先删除`AUTO_INCREMENT`字段，然后重新添加该字段，并附带`AUTO_INCREMENT`关键字。

    ```sql
    ALTER TABLE web_1 DROP sid;
    ALTER TABLE web_1 ADD id INT NOT NULL PRIMARY KEY AUTO_INCREMENT FIRST;
    SELECT * FROM web_1;
    ```

    ```sql
    +----+--------+----------------+
    | id | name   | url            |
    +----+--------+----------------+
    |  1 | 百度   | www.baidu.com  |
    |  2 | 谷歌   | www.google.com |
    |  3 | 必应   | www.bing.com   |
    +----+--------+----------------+
    ```
